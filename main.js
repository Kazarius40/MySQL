// Хочу цей масив з об'єктами відсортувати по category та хочу з нього зробити об'єкт з двома елементами fruit та vegetable, вмістом яких є масив з об'єктами відповідної категорії (category: 'fruit' та category: 'vegetable' відповідно)
const items = [
    { name: 'apple', category: 'fruit' },
    { name: 'carrot', category: 'vegetable' },
    { name: 'banana', category: 'fruit' },
];

// Створив цю змінну лише для того, щоб перевірити кількість проходжень по самому методу reduce (в даному випадку, тут три елементи, то й витків три)
let a = 1;

const grouped = items.reduce((acc, item) => {

    // Перевіряю кількість витків по методу
    console.log(`Заходжу на ${a} виток`);

    // Перевіряю, який елемент масиву (об'єкт) я зараз обробляю
    console.log(item);

    // Ось на цьому місці при першому проходженні по елементам по ідеї у мене мусить бути пустий об'єкт ({}) acc, тому що по опису методу він мусить брати на початку - acc: {} (тобто пустий об'єкт та наповнювати його). Але я бачу, що об'єкт при першому заходженні на виток уже повністю наповнений кінцевими елементами, тобто в консолі те же саме, що і console.log(grouped), хоча на цьому єтапі grouped ще як би не існує (правда питання не до grouped, з цим мені все зрозуміло)
    console.log(acc);

    if (!acc[item.category]) {
        acc[item.category] = [];

        // Ось тут при першому проходженні у мене мусить по ідеї бути створений масив ([]) з ключем назва item.category, але я по факту в консолі бачу вже повністю наповнений масив з елементами, що відповідають ключу item.category. Хоча наповнюється цей масив по ідеї пізніше при виконанні методу push(item)
        console.log(acc[item.category]);
    }

    // Саме тут по ідеї і мусить бути виконано наповнення масиву item.category елементами item, а не вище. І от тут я цього не розумію, чому метод reduce саме так себе веде. Це що виходить, що він зчитує код з декількох рядків одночасно та виконує його до доходження до цього рядка?
    acc[item.category].push(item);

    a++;
    return acc;
}, {});
console.log(grouped);